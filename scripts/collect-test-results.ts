#!/usr/bin/env npx tsx
/**
 * Collect Test Results Script
 *
 * Runs Vitest and collects results programmatically.
 * Updates the manifest with actual pass/fail status.
 *
 * IMPORTANT: This is 100% programmatic - NO LLM involvement.
 * Tests are executed and results are collected automatically.
 *
 * @generated by @hustle-together/api-dev-tools v3.0
 */

import { execSync, spawn } from 'child_process';
import fs from 'fs';
import path from 'path';

// ============================================
// Types
// ============================================

interface TestResult {
  name: string;
  file: string;
  status: 'passed' | 'failed' | 'skipped';
  duration: number;
  error?: string;
}

interface TestSuiteResult {
  file: string;
  tests: TestResult[];
  passed: number;
  failed: number;
  skipped: number;
  duration: number;
}

interface CollectedResults {
  version: string;
  collectedAt: string;
  suites: TestSuiteResult[];
  summary: {
    totalSuites: number;
    totalTests: number;
    passed: number;
    failed: number;
    skipped: number;
    duration: number;
    success: boolean;
  };
}

// ============================================
// Vitest Output Parser
// ============================================

function parseVitestJson(jsonOutput: string): CollectedResults {
  try {
    const data = JSON.parse(jsonOutput);

    const suites: TestSuiteResult[] = [];
    let totalPassed = 0;
    let totalFailed = 0;
    let totalSkipped = 0;
    let totalDuration = 0;

    // Parse Vitest JSON reporter output
    if (data.testResults) {
      for (const fileResult of data.testResults) {
        const suite: TestSuiteResult = {
          file: fileResult.name || fileResult.filepath,
          tests: [],
          passed: 0,
          failed: 0,
          skipped: 0,
          duration: fileResult.duration || 0
        };

        if (fileResult.assertionResults) {
          for (const test of fileResult.assertionResults) {
            const result: TestResult = {
              name: test.title || test.fullName,
              file: suite.file,
              status: test.status === 'passed' ? 'passed' :
                      test.status === 'failed' ? 'failed' : 'skipped',
              duration: test.duration || 0
            };

            if (test.failureMessages && test.failureMessages.length > 0) {
              result.error = test.failureMessages.join('\n');
            }

            suite.tests.push(result);

            if (result.status === 'passed') suite.passed++;
            else if (result.status === 'failed') suite.failed++;
            else suite.skipped++;
          }
        }

        totalPassed += suite.passed;
        totalFailed += suite.failed;
        totalSkipped += suite.skipped;
        totalDuration += suite.duration;

        suites.push(suite);
      }
    }

    return {
      version: '3.0.0',
      collectedAt: new Date().toISOString(),
      suites,
      summary: {
        totalSuites: suites.length,
        totalTests: totalPassed + totalFailed + totalSkipped,
        passed: totalPassed,
        failed: totalFailed,
        skipped: totalSkipped,
        duration: totalDuration,
        success: totalFailed === 0
      }
    };
  } catch (error) {
    throw new Error(`Failed to parse Vitest JSON output: ${error}`);
  }
}

// ============================================
// Console Output Parser (Fallback)
// ============================================

function parseVitestConsole(output: string): CollectedResults {
  const suites: TestSuiteResult[] = [];
  let currentSuite: TestSuiteResult | null = null;

  const lines = output.split('\n');

  for (const line of lines) {
    // Match file header: ‚úì src/path/file.test.ts (5 tests) 123ms
    const fileMatch = line.match(/[‚úì‚úó‚óØ]\s+([^\s]+\.(?:test|spec)\.tsx?)\s+\((\d+)\s+tests?\)/);
    if (fileMatch) {
      if (currentSuite) {
        suites.push(currentSuite);
      }

      const durationMatch = line.match(/(\d+)ms$/);

      currentSuite = {
        file: fileMatch[1],
        tests: [],
        passed: 0,
        failed: 0,
        skipped: 0,
        duration: durationMatch ? parseInt(durationMatch[1]) : 0
      };
      continue;
    }

    // Match test result: ‚úì should do something (5ms)
    const testMatch = line.match(/^\s*([‚úì‚úó‚óØ‚äò])\s+(.+?)(?:\s+\((\d+)ms\))?$/);
    if (testMatch && currentSuite) {
      const [, icon, name, duration] = testMatch;

      const status: 'passed' | 'failed' | 'skipped' =
        icon === '‚úì' ? 'passed' :
        icon === '‚úó' ? 'failed' : 'skipped';

      currentSuite.tests.push({
        name,
        file: currentSuite.file,
        status,
        duration: duration ? parseInt(duration) : 0
      });

      if (status === 'passed') currentSuite.passed++;
      else if (status === 'failed') currentSuite.failed++;
      else currentSuite.skipped++;
    }
  }

  if (currentSuite) {
    suites.push(currentSuite);
  }

  // Calculate summary
  const summary = suites.reduce((acc, suite) => ({
    totalSuites: acc.totalSuites + 1,
    totalTests: acc.totalTests + suite.tests.length,
    passed: acc.passed + suite.passed,
    failed: acc.failed + suite.failed,
    skipped: acc.skipped + suite.skipped,
    duration: acc.duration + suite.duration,
    success: acc.success && suite.failed === 0
  }), {
    totalSuites: 0,
    totalTests: 0,
    passed: 0,
    failed: 0,
    skipped: 0,
    duration: 0,
    success: true
  });

  return {
    version: '3.0.0',
    collectedAt: new Date().toISOString(),
    suites,
    summary
  };
}

// ============================================
// Test Runner
// ============================================

function runVitest(baseDir: string, filter?: string): CollectedResults {
  console.log('üß™ Running Vitest...');

  const vitestArgs = ['vitest', 'run', '--reporter=json'];
  if (filter) {
    vitestArgs.push(filter);
  }

  try {
    // Try running with JSON reporter
    const result = execSync(`npx ${vitestArgs.join(' ')}`, {
      cwd: baseDir,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe'],
      maxBuffer: 50 * 1024 * 1024 // 50MB buffer
    });

    return parseVitestJson(result);
  } catch (error: unknown) {
    // Vitest may exit with non-zero on test failures
    // Try to parse the output anyway
    const execError = error as { stdout?: string; stderr?: string };
    if (execError.stdout) {
      try {
        return parseVitestJson(execError.stdout);
      } catch {
        // Fall back to console parsing
        return parseVitestConsole(execError.stdout);
      }
    }

    // Try fallback: run without JSON reporter
    console.log('   ‚ö†Ô∏è  JSON reporter failed, trying console output...');

    try {
      const consoleResult = execSync(`npx vitest run ${filter || ''}`, {
        cwd: baseDir,
        encoding: 'utf-8',
        stdio: ['pipe', 'pipe', 'pipe']
      });

      return parseVitestConsole(consoleResult);
    } catch (fallbackError: unknown) {
      const fbError = fallbackError as { stdout?: string };
      if (fbError.stdout) {
        return parseVitestConsole(fbError.stdout);
      }
      throw error;
    }
  }
}

// ============================================
// Manifest Updater
// ============================================

function updateManifest(manifestPath: string, results: CollectedResults): void {
  if (!fs.existsSync(manifestPath)) {
    console.log('   ‚ö†Ô∏è  Manifest not found, skipping update');
    return;
  }

  const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));

  // Create a map of test results by file
  const resultsByFile = new Map<string, TestSuiteResult>();
  for (const suite of results.suites) {
    const basename = path.basename(suite.file);
    resultsByFile.set(basename, suite);
  }

  // Update each endpoint's test status
  if (manifest.endpoints) {
    for (const endpoint of manifest.endpoints) {
      const testBasename = path.basename(endpoint.testFile || '');
      const suiteResult = resultsByFile.get(testBasename);

      if (suiteResult) {
        endpoint.testResults = {
          passed: suiteResult.passed,
          failed: suiteResult.failed,
          skipped: suiteResult.skipped,
          duration: suiteResult.duration,
          lastRun: results.collectedAt
        };
      }
    }
  }

  // Update summary
  manifest.lastTestRun = {
    ...results.summary,
    timestamp: results.collectedAt
  };

  fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
  console.log(`   ‚úÖ Updated manifest with test results`);
}

// ============================================
// CLI Entry Point
// ============================================

function main() {
  const args = process.argv.slice(2);
  const baseDir = args[0] || process.cwd();
  const filter = args[1] || undefined;
  const outputPath = args[2] || path.join(baseDir, 'src', 'app', 'api-test', 'test-results.json');
  const manifestPath = path.join(baseDir, 'src', 'app', 'api-test', 'api-tests-manifest.json');

  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('  üß™ Test Results Collector');
  console.log('  @hustle-together/api-dev-tools v3.0');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log(`\nüìÅ Base directory: ${baseDir}`);
  if (filter) {
    console.log(`üîç Filter: ${filter}`);
  }
  console.log(`üìÑ Output file: ${outputPath}\n`);

  try {
    const results = runVitest(baseDir, filter);

    // Ensure output directory exists
    const outputDir = path.dirname(outputPath);
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Write results
    fs.writeFileSync(outputPath, JSON.stringify(results, null, 2));

    // Update manifest with results
    updateManifest(manifestPath, results);

    console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    if (results.summary.success) {
      console.log('  ‚úÖ All tests passed!');
    } else {
      console.log('  ‚ùå Some tests failed');
    }
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    console.log(`\nüìä Summary:`);
    console.log(`   ‚Ä¢ Suites: ${results.summary.totalSuites}`);
    console.log(`   ‚Ä¢ Tests: ${results.summary.totalTests}`);
    console.log(`   ‚Ä¢ Passed: ${results.summary.passed} ‚úì`);
    if (results.summary.failed > 0) {
      console.log(`   ‚Ä¢ Failed: ${results.summary.failed} ‚úó`);
    }
    if (results.summary.skipped > 0) {
      console.log(`   ‚Ä¢ Skipped: ${results.summary.skipped} ‚äò`);
    }
    console.log(`   ‚Ä¢ Duration: ${results.summary.duration}ms`);

    // List failed tests
    const failedTests = results.suites.flatMap(suite =>
      suite.tests.filter(t => t.status === 'failed').map(t => ({
        file: suite.file,
        name: t.name,
        error: t.error
      }))
    );

    if (failedTests.length > 0) {
      console.log(`\n‚ùå Failed tests:`);
      for (const test of failedTests) {
        console.log(`   ‚Ä¢ ${test.file}: ${test.name}`);
        if (test.error) {
          console.log(`     ${test.error.split('\n')[0]}`);
        }
      }
    }

    console.log(`\nüìÑ Results: ${outputPath}`);
    console.log(`üìÑ Manifest: ${manifestPath}\n`);

    // Exit with appropriate code
    process.exit(results.summary.success ? 0 : 1);

  } catch (error) {
    console.error('\n‚ùå Failed to collect test results:', error);
    process.exit(1);
  }
}

main();
