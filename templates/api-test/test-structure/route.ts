/**
 * Test Structure Parser API
 *
 * Parses Vitest test files and returns the test structure for UI display.
 * Vitest tests are the SOURCE OF TRUTH - this API only reads and parses them.
 *
 * @generated by @hustle-together/api-dev-tools v3.0
 */

import { NextRequest, NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';

// ============================================
// Types
// ============================================

interface TestCase {
  name: string;
  line: number;
  status: 'pending' | 'passed' | 'failed' | 'skipped';
  duration?: number;
  error?: string;
}

interface TestGroup {
  name: string;
  line: number;
  tests: TestCase[];
  groups: TestGroup[];
}

interface TestFeature {
  file: string;
  relativePath: string;
  groups: TestGroup[];
  totalTests: number;
  passedTests: number;
  failedTests: number;
  skippedTests: number;
}

interface TestStructure {
  features: TestFeature[];
  totalTests: number;
  passedTests: number;
  failedTests: number;
  skippedTests: number;
  parsedAt: string;
}

// ============================================
// Parser Logic (brace counting + regex)
// ============================================

/**
 * Parse a single test file and extract describe/it blocks
 * Uses brace counting to handle nested structures
 */
function parseTestFile(content: string, filePath: string): TestFeature {
  const lines = content.split('\n');
  const rootGroups: TestGroup[] = [];
  const groupStack: TestGroup[] = [];

  let braceCount = 0;
  let inDescribe = false;
  let currentDescribeBraceStart = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineNum = i + 1;

    // Match describe blocks: describe('name', () => { or describe("name", function() {
    const describeMatch = line.match(/describe\s*\(\s*['"`]([^'"`]+)['"`]/);
    if (describeMatch) {
      const group: TestGroup = {
        name: describeMatch[1],
        line: lineNum,
        tests: [],
        groups: []
      };

      if (groupStack.length > 0) {
        groupStack[groupStack.length - 1].groups.push(group);
      } else {
        rootGroups.push(group);
      }

      groupStack.push(group);
      inDescribe = true;
      currentDescribeBraceStart = braceCount;
    }

    // Match it/test blocks: it('name', ...) or test('name', ...)
    const testMatch = line.match(/(?:it|test)\s*\(\s*['"`]([^'"`]+)['"`]/);
    if (testMatch && groupStack.length > 0) {
      const testCase: TestCase = {
        name: testMatch[1],
        line: lineNum,
        status: 'pending' // Will be updated by test runner results
      };

      // Check for .skip or .todo
      if (line.includes('.skip') || line.includes('.todo')) {
        testCase.status = 'skipped';
      }

      groupStack[groupStack.length - 1].tests.push(testCase);
    }

    // Count braces to track scope
    const openBraces = (line.match(/{/g) || []).length;
    const closeBraces = (line.match(/}/g) || []).length;
    braceCount += openBraces - closeBraces;

    // Pop group from stack when we close its scope
    if (inDescribe && braceCount <= currentDescribeBraceStart && groupStack.length > 0) {
      groupStack.pop();
      if (groupStack.length === 0) {
        inDescribe = false;
      } else {
        // Update brace start for parent describe
        currentDescribeBraceStart = braceCount;
      }
    }
  }

  // Count tests
  const countTests = (groups: TestGroup[]): { total: number; passed: number; failed: number; skipped: number } => {
    let total = 0, passed = 0, failed = 0, skipped = 0;

    for (const group of groups) {
      for (const test of group.tests) {
        total++;
        if (test.status === 'passed') passed++;
        else if (test.status === 'failed') failed++;
        else if (test.status === 'skipped') skipped++;
      }
      const nested = countTests(group.groups);
      total += nested.total;
      passed += nested.passed;
      failed += nested.failed;
      skipped += nested.skipped;
    }

    return { total, passed, failed, skipped };
  };

  const counts = countTests(rootGroups);

  return {
    file: path.basename(filePath),
    relativePath: filePath,
    groups: rootGroups,
    totalTests: counts.total,
    passedTests: counts.passed,
    failedTests: counts.failed,
    skippedTests: counts.skipped
  };
}

/**
 * Find all test files in the project
 */
function findTestFiles(baseDir: string): string[] {
  const testFiles: string[] = [];
  const testPatterns = [
    '**/*.test.ts',
    '**/*.test.tsx',
    '**/*.spec.ts',
    '**/*.spec.tsx',
    '**/__tests__/**/*.ts',
    '**/__tests__/**/*.tsx'
  ];

  function walkDir(dir: string) {
    try {
      const entries = fs.readdirSync(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);

        // Skip node_modules and hidden directories
        if (entry.isDirectory()) {
          if (entry.name === 'node_modules' || entry.name.startsWith('.')) {
            continue;
          }
          walkDir(fullPath);
        } else if (entry.isFile()) {
          // Check if file matches test patterns
          if (
            entry.name.endsWith('.test.ts') ||
            entry.name.endsWith('.test.tsx') ||
            entry.name.endsWith('.spec.ts') ||
            entry.name.endsWith('.spec.tsx')
          ) {
            testFiles.push(fullPath);
          }
        }
      }
    } catch (error) {
      // Ignore permission errors
    }
  }

  walkDir(baseDir);
  return testFiles;
}

// ============================================
// API Handler
// ============================================

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const testPath = searchParams.get('path');
    const baseDir = process.cwd();

    let testFiles: string[];

    if (testPath) {
      // Parse specific test file
      const fullPath = path.join(baseDir, testPath);
      if (!fs.existsSync(fullPath)) {
        return NextResponse.json(
          { error: `Test file not found: ${testPath}` },
          { status: 404 }
        );
      }
      testFiles = [fullPath];
    } else {
      // Find all test files
      testFiles = findTestFiles(baseDir);
    }

    const features: TestFeature[] = [];

    for (const file of testFiles) {
      try {
        const content = fs.readFileSync(file, 'utf-8');
        const relativePath = path.relative(baseDir, file);
        const feature = parseTestFile(content, relativePath);
        features.push(feature);
      } catch (error) {
        // Skip files that can't be read
        console.error(`Failed to parse ${file}:`, error);
      }
    }

    // Aggregate counts
    const structure: TestStructure = {
      features,
      totalTests: features.reduce((sum, f) => sum + f.totalTests, 0),
      passedTests: features.reduce((sum, f) => sum + f.passedTests, 0),
      failedTests: features.reduce((sum, f) => sum + f.failedTests, 0),
      skippedTests: features.reduce((sum, f) => sum + f.skippedTests, 0),
      parsedAt: new Date().toISOString()
    };

    return NextResponse.json(structure);
  } catch (error) {
    console.error('Test structure parser error:', error);
    return NextResponse.json(
      { error: 'Failed to parse test structure', details: String(error) },
      { status: 500 }
    );
  }
}
